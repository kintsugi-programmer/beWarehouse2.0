# GDD

## 1. Games 

![alt text](image-7.png)

**Definition of a Game**
- A game can be defined as a **rule-based formal system** with a **variable and quantifiable outcome**.
- Outcomes in a game are assigned different values.
- The player exerts effort in order to influence the outcome.
- The player feels attached to the outcome.
- The consequences of the activity are optional and negotiable.

**Elements of a "Killer Game"**
- Is there a formula to design a killer game? The sources list the following elements:
    - **Aesthetic** (Ae)
    - **Fun** (Fu)
    - **Character** (Cr)
    - **Levels** (Lv)
    - **Addiction** (Ad)
    - **Story** (St)
    - **Mechanic** (Me)
    - **Genre** (Ge)
    - **Audio** (Au)
    - **Originality** (Or)
    - **Feel** (Fe)
    - **Pacing** (Pa)
    - **Art** (Ar)
    - **Coding** (Co)
    - **Interface** (In)
    - **Strategy** (St)
    - **Reward** (Rw)
    - **Planning** (Pl)
    - **Feedback** (Fe)
    - **Testing** (Te)
- These elements are part of the **creative process for designing games**.

**Rules and Game Mechanics**
- **Core Concept**: What all games share with one another is **rules**.
- **Video Games**: In video games, rules can also be thought of as the game’s **mechanic**.
- **Example**: The mechanic of a first-person shooter (FPS) game is shooting things.
- **Action Definition**: The action of the game is defined by the mechanic of:
    - Damage
    - Aiming
    - Running
    - Jumping
    - Hiding
- **World Rules**: The game mechanic is also informed by the rules of the world, such as:
    - What you can and cannot shoot.
    - How much damage you can inflict or sustain.
- **Discipline of Game Design**: Minor additions to game rules speak to the discipline of game design. These include:
    - Time limits
    - Proximity
    - Agreements of fairness

**Game Evolution and Variants**
- More games evolve from variations on a core mechanic.
- This phenomenon is common to game design.
- **Example Case Study: Tag vs. Stick in the Mud**:
    - From a **“core” game** (such as tag) emerge **variants** (such as “stick in the mud”).
    - It is the same game but with a **twist**: tagged players are stuck.
    - Another “free” player must tag the stuck players to liberate them from the imagined “mud”.
    - The goal of the “it” player in this variant is to **entrap all of the active players** in order to “win”.

**Definition of Play**
- **Nature of Activity**: Play is a free activity standing quite consciously **outside “ordinary” life**.
- **Material Interest**: It is an activity connected with **no material interest**, and **no profit** can be gained by it.
- **Structure**: It proceeds within its own proper boundaries of time and space according to **fixed rules** and in an orderly manner.
- **Boundaries**: Play, unlike real life, can take place anywhere and for any amount of time.
- **Control**: Play is **controlled** and **excludes** those not playing the game.
- **Purpose**: Play is essentially a **reward unto itself**.

**Classroom Activities (Using Miro)**
- **Activity 1**:
    - Divide into teams.
    - Each team must bring out **2 core games** and tell the **variants available as video games**.
- **Activity 2**:
    - Answer the question: Do you take **Social Media** as a game?.
    - If yes, **list down the rules/mechanics** of this game.
- **Activity 3**:
    - Take a game and **dissect its game rules and mechanics**.
    - Answer: What do the rules tell you about the game?.
    - Answer: How do the mechanics support and enhance both the rules and the gameplay?.

## 2. The Game World

![alt text](image-5.png)

-   **Questions to Ask Before Game Design**
    -   In what way is my world more interesting than the real world?
    -   Does my world focus on one individual’s story or can several stories be told?
    -   How will the player internalize my world?

-   **Constructing a Universe**
    -   When you build a game, you construct a Universe.
    -   It will have:
        -   **Physics**
        -   **Boundaries**
        -   **Interfaces**

-   **The Building Blocks of Game World Design**
    -   **The Field of Play**
    -   **The Game Mechanic**
    -   **The Rules of Play**
    -   **The Outcomes of Play**
    -   **The Objectives of Play**
    -   **Player Resources and Conflict**

-   **Detailed Analysis of Building Blocks**
    -   **The Field of Play**
        -   **Consistency:** The field of play has to be consistent and work within the mechanics and rules of the game world.
        -   **Interface Design:** The design of the interface between the player and the world is also an aspect of the field of play.
            -   This involves how the player navigates through the world and how the world reacts to the player.
        -   **Boundaries:** The field of play can also be thought of as the game’s boundaries, tasks, and outcomes.
        -   **Media Definition:** The field of play is defined by the media it is played on.
        -   **Stability vs. Change:** Game worlds can be generated to be infinite or ever-changing, but the rules and mechanic must remain consistent.
        -   **Level Design:** The field of play can constrain and guide the player towards a goal (this is part of level design).

    -   **The Game Mechanic**
        -   **Definition:** The mechanic of a video game does not just refer to the “nuts and bolts” of the game or just the programming and art assets.
        -   **Core Function:** The mechanic is what the game is, how it plays, and how the player interacts with the game.
        -   **Scope:** Mechanics explain the gameplay, environment, and physics of the world.
        -   **Player Interaction:** They are what a player can and cannot do, as well as how they interact within the game space.

    -   **The Rules of Play**
        -   **Action Limitation:** Rules limit actions.
        -   **Clarity:** Rules must be explicit, unambiguous, and consistent.
        -   **Fairness:** The game should never give the impression of “cheating” the player by changing rules and outcomes on the fly.
        -   **Consistency Scope:** Rules have to be consistent within the game, but they do not have to be consistent across games.
        -   **Space and Action:** In video games, the rules define the potentiality of any space for play and define and restrict an array of possible actions.

-   **General Document Requirements**
    -   A general document should include the following elements:
        -   **Overview:** An overview of the game’s premise, covering what the game is and what platform it is intended for.
        -   **Story:** The story (if there is one).
        -   **Level Concepts:** Concepts for level designs and environments (which could be mood boards or sketched art).
        -   **Gameplay:** Details on what the mechanic is and what the rules are.
        -   **Art:** Sketches, mood boards, and tone art to show what the world looks like.
        -   **Sound and Music:**
            -   How much will there be?
            -   Do specific characters have specific sounds?
            -   Does each level require new music?
        -   **User Interface:**
            -   Game controls.
            -   Controls may change once production is underway, but it is useful to know if the game has “conventional” controls and interfaces or if it is bringing something unique or unusual to the genre.

## 3. Ludology

![alt text](image-6.png)

- **Ludology**
    - **Definition**: The name for the study of games and game design.
    - **Common Frameworks for Ludology**:
        - **MDA**: Mechanics, Dynamics, and Aesthetics.
        - **FDD**: Formal, Dramatic, and Dynamic elements.
        - **Elemental Tetrad**: Splits games into four core elements (Mechanics, Aesthetics, Story, Technology).

- **MDA Framework (Mechanics, Dynamics, and Aesthetics)**
    - **Overview**: A framework defining the components of a game and how they interact with players and designers.
    - **The Three Components**:
        - **Mechanics**:
            - The particular components of the game at the level of data representation and algorithms.
        - **Dynamics**:
            - The runtime behavior of the mechanics acting on player inputs and each other’s outputs over time.
        - **Aesthetics**:
            - The desirable **emotional responses** evoked in the player when they interact with the game system.
    - **Designer and Player Views**:
        - Designers create Mechanics, which create Dynamics, which lead to Aesthetics.
        - Players experience the game in reverse: they experience Aesthetics through Dynamics, which are driven by Mechanics.

- **FDD Framework (Formal, Dramatic, and Dynamic Elements)**
    - **Formal Elements**:
        - **Definition**: The elements that make games different from other forms of media or interaction and provide the structure of a game.
        - **Seven Formal Elements** (proposed by *Game Design Workshop*):
            - **1. Player interaction pattern**:
                - How the players interact.
                - **Types**:
                    - Single-player.
                    - One-on-one.
                    - Team versus team.
                    - Multilateral: Multiple players versus each other (e.g., most board games).
                    - Unilateral: One player versus **all the other players** (e.g., some *Mario Party* minigames or the board game *Scotland Yard*).
                    - Cooperative play.
                    - Multiple individual players each working against the same system.
            - **2. Objective**:
                - What the players are trying to achieve.
                - Defines when someone has won the game.
            - **3. Rules**:
                - Limit the players’ actions by telling them what they may and may not do.
                - **Explicit Rules**: Written and included in the game.
                - **Implicit Rules**: Understood by all players without being written (e.g., it is understood you cannot steal money from the bank in *Monopoly*, even though no rule explicitly says so).
            - **4. Procedures**:
                - The types of actions taken by the players in the game.
                - Often defined by the interaction of a number of rules.
                - **Example**: In *Snakes and Ladders*, a rule tells you to roll the die and move; the **procedure** is the actual action of rolling the die and moving the piece.
            - **5. Resources**:
                - Elements that have value in the game.
                - **Examples**: Money, health, items, and property.
            - **6. Boundaries**:
                - Where the game ends and reality begins.
            - **7. Outcome**:
                - How the game ended.
                - Can be both final and incremental outcomes.

    - **Dramatic Elements**:
        - **Definition**: The story and narrative of the game, including the premise.
        - **Purpose**: Help make rules and resources more understandable and give players greater emotional investment.
        - **Three Types of Dramatic Elements** (Fullerton):
            - **1. Premise**:
                - The basic story of the game world.
                - Forms the basis around which the rest of the game’s narrative is built.
                - **Examples**:
                    - *Monopoly*: Each player is a real-estate developer trying to get a monopoly on corporate real estate in Atlantic City, New Jersey.
                    - *Donkey Kong*: The player tries to single-handedly save his girlfriend from a gorilla that kidnapped her.
            - **2. Character**:
                - The individuals around whom the story revolves.
                - Ranges from nameless/undefined silent first-person characters to defined individuals.
            - **3. Story**:
                - The plot of the game.
                - The actual narrative that takes place through the course of the game (the premise sets the stage for this).

    - **Dynamic Elements**:
        - **Definition**: The game in motion.
        - Elements that occur **only** when the game is being played (when players turn rules into actual gameplay).
        - **Key Concepts**:
            - **Emergence**: Collisions of seemingly simple rules can lead to unpredictable outcomes.
            - **Emergent Narrative**:
                - Narrative can be dynamic, with a breadth of narratives emerging from the gameplay itself.
                - This is distinct from the dynamic behavior of mechanics in MDA.
                - Games put players in extra-normal situations, leading to interesting stories.

- **The Elemental Tetrad**
    - **Overview**: A framework (attributed to Schell) splitting games into four core elements that interrelate.
    - **Nature of the Framework**:
        - Focuses on the **static elements** of the game "as it comes in a box".
        - Does not touch on dynamic play.
    - **Visibility**:
        - **More Visible**: Aesthetics (always very visible to the player).
        - **Less Visible**: Technology (players usually understand mechanics better than the underlying technology, like probability distributions).
    - **The Four Elements**:
        - **1. Mechanics**:
            - The rules for interaction between the player and the game.
            - Differentiates games from noninteractive media.
            - Includes rules, objectives, and formal elements.
            - **Difference from MDA**: Here, the term differentiates game mechanics from the underlying technology.
        - **2. Aesthetics**:
            - How the game is perceived by the **five senses**: vision, sound, smell, taste, and touch.
            - Includes soundtrack, character models, packaging, and cover art.
            - **Difference from MDA**: MDA uses "aesthetics" to refer to emotional response; Tetrad uses it to refer to sensory input.
        - **3. Technology**:
            - The underlying technology that makes the game work.
            - **Digital Examples**: Console hardware, software, rendering pipelines.
            - **Analog/Board Game Examples**: Type and number of dice, use of cards vs. dice as randomizers, stats and tables used to determine outcomes.
        - **4. Story**:
            - Encompasses all narrative elements, including both premise and characters.

## 4. THE UNREAL ENGINE 5.6.1 (Class - 1)

![alt text](image.png)

**Date:** 2 February 2026

### 1. Editor Basics

#### 1.1 Editor Layout
*   **Viewport:** Main 3D area where levels are built.
*   **Outliner:** Lists all actors in the scene.
*   **Details Panel:** Shows editable properties of the selected actor.
*   **Content Drawer:** Stores all project assets.
*   **Place Actors Panel:** Drag shapes, lights, and volumes into the scene.

#### 1.2 Essential Shortcuts
| Action | Shortcut |
| :--- | :--- |
| **Content Drawer** | `Ctrl` + `Spacebar` |
| **Move Camera** | `Right-click` + `W`/`A`/`S`/`D`/`E`/`Q` |
| **Fast Camera Movement** | Hold `Middle Mouse Button` + Scroll Up |
| **Slow Camera Movement** | Hold `Middle Mouse Button` + Scroll Down |
| **Focus Object** | `F` |
| **Save Level** | `Ctrl` + `S` |
| **Grouping Meshes** | `Ctrl` + `G` |
| **Ungrouping Meshes** | `Shift` + `G` |
| **Duplicate Object** | `Alt` + Drag |
| **Move Tool** | `W` |
| **Rotate Tool** | `E` |
| **Scale Tool** | `R` |
| **Directional Lighting** | `Ctrl` + `L` |


#### 1.3 What is the Content Drawer?
The **Content Drawer** is Unreal Engine’s central asset management panel. It functions as the project’s file system and displays everything stored in the `/Content/` directory.

It contains every asset used in the project, including:
*   Materials
*   Textures
*   Meshes
*   Blueprints
*   Animations
*   Audio files
*   Levels
*   Imported content

##### 1.3.1 Key Functions
*   Stores all project assets in organised folders.
*   Allows importing files such as textures, models, and audio.
*   Provides quick search and filtering for any asset.
*   Supports drag-and-drop into the viewport for fast level construction.
*   Enables creation of new assets (Blueprints, Materials, Levels, etc.).

##### 1.3.2 Accessing the Content Drawer
*   Press `Ctrl` + `Space` to toggle it instantly.
*   Click the **drawer tab** located at the bottom-center of the Unreal Editor.
*   Alternatively, go to **Window** $\rightarrow$ **Content Browser**.

**Note:** The Content Drawer is a fundamental workspace where every asset is accessed, organised, and managed while building a UE5 project.

---

### 2. Introduction to FAB

**FAB** is Epic Games’ unified asset marketplace introduced to integrate high-quality digital assets directly into Unreal Engine. It replaces older stores like the **Unreal Marketplace** and **Quixel Bridge** with a single ecosystem.

FAB provides ready-to-use assets for:
*   Environments
*   Characters
*   Materials
*   Foliage
*   Props
*   Visual effects

#### 2.1 Key Features of FAB
*   **Unified Marketplace:** All assets from the Unreal Marketplace, Quixel Megascans, Sketchfab, and other sources are available in one place.
*   **High-Quality Free Assets:** Many assets (grass, rocks, landscapes, materials) are available free for UE users.
    *   To select free assets, change the price tag to show only free assets.
*   **One-Click Import:** Assets can be downloaded and added directly to your project from inside Unreal Engine.
*   **Wide Range of Categories:** Includes foliage, architecture sets, characters, surfaces, decals, and terrain tools.
*   **Optimized for UE5:** Assets follow Nanite, Lumen, and modern UE workflow standards.

#### 2.2 Accessing FAB in Unreal Engine
1.  Open the **Content Drawer**.
2.  Click on the **Fab button** at the bottom toolbar.
3.  Browse categories such as:
    *   Foliage (grass, bushes, trees)
    *   Surfaces (brick, wood, concrete)
    *   Architecture
    *   Props and furniture
4.  Select an asset and click **Add to Project**.

**Example:** FAB Grass is one of the commonly used assets for painting natural grass onto landscapes using the **Foliage Mode**.

---

### 3. Creating a New Level

#### 3.1 Starting a Level From Scratch
1.  Go to **Content Drawer** $\rightarrow$ **Right Click** $\rightarrow$ **New Level**.
2.  Select **Empty Level**.
3.  The level will initially appear blank.

#### 3.2 Add Essential Actors
Before constructing architecture, click **Window** $\rightarrow$ **Env. Light Mixture**, then add the following:
*   Sky Atmosphere
*   Directional Light (sun)
*   Sky Light
*   Player Start
*   Exponential Height Fog

**Shortcut:** Press `Ctrl` + `L` to rotate sunlight interactively.

---

### 4. Basic Shapes (Primitives)

#### 4.1 Available Shapes
Under the **Place Actors Panel** $\rightarrow$ **Shapes**:
*   Cube
*   Sphere
*   Cylinder
*   Cone
*   Plane

#### 4.2 Adding Shapes
*   Drag shape into the viewport, OR
*   **Right-click** in the viewport $\rightarrow$ **Add Shape**.

---

### 5. Building a Simple Room

This workflow constructs a basic house or room using Unreal Engine’s shapes and Modeling Mode. The goal is to create a floor, four walls, a ceiling, a door opening, and add indoor spot lights.

#### 5.1 Step 1: Create the Floor
1.  Go to the **Landscape Mode** from the selection mode and add a landscape into the viewport.
2.  This forms the base floor of your level.

#### 5.2 Step 2: Make a Door Opening
Drag the **Door** static mesh present in the content drawer.

##### 5.2.1 Making the Door:
1.  You will see 3 static meshes and a blueprint frame.
2.  You have to use the **DoorFrame Corner** and **DoorFrame Edge** static meshes.
3.  Create a door using them.
4.  Use the `Shift` key to select multiple objects/assets and duplicate to make the door faster.

#### 5.3 Step 3: Create the Walls
Create four walls:
1.  Drag a **Cube** into the viewport.
2.  Move it to one side of the floor.
3.  Duplicate the wall using `Alt` + Drag.
4.  Position duplicates to form all four sides.

#### 5.4 Step 5: Adding Spot Lights Inside the Room
1.  Open the **Place Actors** panel.
2.  Search for **Spot Light**.
3.  Drag the Spot Light into the room interior.
4.  Position the Spot Light near the ceiling and aim it downward using the rotation tool (`E`).
5.  Duplicate multiple Spot Lights (`Alt` + Drag) for even lighting in the room.

#### 5.5 Step 6: Test the Space
*   Press **Play** to explore the room.
*   Walk around using `WASD`.
*   Ensure the lighting, ceiling height, and door opening feel correct.

---

### 6. Foliage

Unreal Engine’s **Foliage Mode** allows fast placement of grass, plants, rocks, and other natural assets across large surfaces.

#### 6.1 Using FAB Grass
1.  Go to the top-left corner and switch to **Foliage Mode**.
2.  In the Foliage panel, click the **+ Add** button and search for **FAB Grass**.
3.  Enable the checkbox next to the grass asset.
4.  Adjust brush settings:
    *   **Brush Size**
    *   **Density** (amount of grass per stroke)
    *   **Paint Radius**
5.  Click and drag across your landscape to paint grass.

**Tip:** To erase grass, hold `Shift` while painting.

---

### 7. Precision Tools

#### 7.1 Transform Controls
Use the **Details panel** for:
*   Exact location values
*   Rotation in degrees
*   Scale values

#### 7.2 Snapping Controls
*   **Translation Snap:** 10 units (default)
*   **Rotation Snap:** 10 degrees (default)
*   **Scale Snap:** optional

---

### 8. Play Testing

#### 8.1 Testing Your Level
*   Add a **Player Start** from **Place Actors Panel** to make a starting point for your player.
*   Press **Play** to enter gameplay preview.
*   Use `WASD` to move, mouse to look.
*   Press `ESC` to exit.

## 5. UE5 Modeling and Collision Super-Depth Notes

![alt text](image-1.png)

- https://www.youtube.com/watch?v=9xS62nqgExM
- https://www.youtube.com/watch?v=xo7FpCRWcqo
- https://www.youtube.com/watch?v=5m3-ODwE_oU

### 1. Core Concept: The In-Engine Workflow
**Modeling Mode** allows for a "Model from Scratch" workflow directly within the Unreal Engine viewport.
*   **Purpose:** rapid iteration, non-destructive editing, prototyping.
*   **Benefit:** Eliminates the need to export/import FBX files from external DCCs (Digital Content Creation tools like Blender, 3ds Max, Maya).
*   **Use Case:** Best for simple geometric shapes (walls, doors, windows, staircases).
*   **Access:** Change **Selection Mode** to **Modeling** or press `Shift + 5`.

#### Project Setup for Modeling
To organize generated assets automatically:
1.  Go to **Edit > Project Settings**.
2.  Navigate to **Plugins > Modeling Mode**.
3.  Under **Generated Assets**, change "Asset Generation Location" to **Global Asset Path**.
4.  Set the path name (e.g., `MyModels`).
    *   *Note:* Disabling "Per User Folder" prevents creating username subfolders, useful for single developers.

---

### 2. Primary Toolset: Cube Grid
The **Cube Grid** is the foundational tool for blocking out architectural volumes. It operates on a 2D selection grid projected into 3D space.

#### Grid Mechanics and Precision
*   **Grid Visualization:** Based on a 2D grid projected onto the floor or object surfaces.
*   **Mathematical Precision:**
    *   Formula: `Step Size = 2^n * 10 units`.
    *   **Common Increments:**
        *   **100 cm:** Standard unit for large-scale blocking.
        *   **50 cm:** Thick structural walls/floors.
        *   **10 cm:** Detail work (frames, steps).
*   **Shortcuts for Grid Size:**
    *   `Ctrl + E`: Double the grid size.
    *   `Ctrl + Q`: Halve the grid size.
    *   **Grid Power:** Can be manually adjusted in settings (e.g., Grid Power 5 = 100cm blocks).

#### Selection and Manipulation Actions
*   **Grid Selection:** Click and drag on the grid to define a face/area.
*   **Extrusion (`E`):** Moves the selected face **outward** by one grid increment (adds geometry).
*   **Depression/Subtraction (`Q`):** Pushes the face **inward**, effectively deleting geometry or creating voids (cuts).
*   **Interactive Push/Pull:**
    *   Hold `Ctrl` + Left Mouse Drag: Interactively pulls geometry out or pushes it in (cut) without using `E` or `Q`.
*   **Corner Mode (`Z`):** Allows selection of individual grid corners to create slanted, diagonal, or trapezoidal surfaces.

---

### 3. Construction Workflows

#### A. Basic Room Construction
1.  **Floor:**
    *   Set snapping/grid size to **100**.
    *   Drag selection on the ground (e.g., 10x10 meters).
    *   Press `E` to extrude up by one unit (creates thickness).
2.  **Walls:**
    *   Select the outer perimeter of the floor mesh.
    *   Press `E` multiple times (e.g., 4 times for 4 meters) or `Ctrl + Drag` up.
3.  **Hollowing (Alternative Method):**
    *   Build a solid block first.
    *   Select the inner grid squares.
    *   Press `Q` to push down until the floor is revealed.
    *   *Warning:* If you press `Q` one too many times, you will delete the floor. Press `E` to add it back.
4.  **Windows and Doors (Boolean-style):**
    *   Select a grid area on a vertical wall (e.g., 1x2 for window, 2x3 for door).
    *   Press `Q` or `Ctrl + Drag` backward to punch a hole.
    *   **Manifold-Safe:** Unreal automatically handles the side-faces (caps) of the hole.
5.  **Revising Openings:**
    *   If a window is too high/wrong size: `Ctrl + Drag` the edge of the hole to fill it back in, then re-cut at the correct position.

#### B. Roof Geometry (Sloped/Pitched)
1.  Extrude the top of the structure to the desired roof height.
2.  Select the section to be sloped.
3.  Enter **Corner Mode** (Tool icon or press `Z`).
4.  Select the corner vertices or the ridge line (center edge).
5.  Press `Q` or drag down to slope the geometry.
6.  **Overhangs:**
    *   Use a smaller grid size (e.g., 25cm).
    *   Extrude a strip outward from the roof base.
    *   Use Corner Mode to slant the top of the overhang to match the roof pitch.

#### C. Staircase Design

##### Method 1: The Staggered Method (Cube Grid)
"Draw" the steps manually using Cube Grid.
*   **Rise:** 20 cm (Vertical).
*   **Run:** 30–40 cm (Horizontal).
*   **Process:** Extrude blocks iteratively to form steps.

##### Method 2: Primitive + Plane Cut (Automated)
1.  **Create Primitive:** Use the **Stair** shape tool from the Modeling tab.
    *   Configure: Number of steps, Step Width, Step Height.
    *   Set to **Dynamic Mesh** (temporary).
2.  **Cut in Half (for landings/turns):**
    *   Select the stair mesh.
    *   Use **Plane Cut** tool (under TriModel).
    *   Rotate cut plane 90 degrees (vertical cut).
    *   **Options:** Check "Keep Both Halves" and "Fill Cut Hole".
3.  **re-orient:** Rotate and move the separated halves to form a turn (e.g., L-shape).
4.  **Fill Gap:** Create a Box (Dynamic Mesh) to serve as the landing platform.
5.  **Aligning Geometry (PolyEdit):**
    *   If gaps exist, use **PolyEdit**.
    *   Select the face of the landing platform.
    *   Drag the face and hold `Ctrl` while hovering over a vertex on the stair mesh to **Snap** perfectly to it.
6.  **Merge:**
    *   Select all parts (Stairs + Landing).
    *   Use **Mesh Ops > Union** to merge into a single asset.
7.  **Pivot Adjustment:** Use **Pivot** tool -> Set to "Bottom" for easier placement.

#### D. Mirroring Structures
If complex details (like roof overhangs) are built on one side:
1.  Select the mesh.
2.  Use the **Mirror** tool (under TriModel).
3.  Adjust the mirror plane (drag gizmo to center).
4.  **Settings:**
    *   **Mirror and Append:** Keeps both sides.
    *   **Weld Vertices:** Merges duplicate vertices at the seam.
    *   **Crop along mirror plane:** Removes geometry crossing the line before mirroring.

---

### 4. Mesh Refinement and Texturing

#### PolyGroup Optimization
*   **PolyGroups:** These are the equivalent of "Faces" in other software.
*   **Clean Up:** After blocking, use **PolyGroup Edit** to clean geometry.
    *   **Merge Faces:** Combine multiple small faces (e.g., side of stairs) into a single PolyGroup.
    *   **Beveling:** Select edges to add a chamfer to reduce digital sharpness.

#### Materials
*   **Assignment:** Drag and drop materials or select via the Details panel.
*   **Multi-Material Setup (Material Edit Tool):**
    *   Use the **Material Edit** tool (Attributes section).
    *   Add a new material slot (e.g., Roof Tiles).
    *   **Selection:** Set Brush Mode to **All in Group**. Click to select specific faces (PolyGroups) like the roof slope.
    *   **Action:** Click "Assign Active Material".

#### UVs and Normals
*   **Fixing Stretched Textures:**
    *   Use the **Project** tool (under UVs).
    *   **Projection Type:**
        *   **Plane:** Good for top-down surfaces.
        *   **Box:** Projects on all 3 orthogonal planes (fixes sides and risers of stairs).
    *   **Scale:** Adjust UV scale numbers (e.g., 4 or 5) to match surrounding assets.
*   **Fixing Flat Lighting:**
    *   If a mesh looks flat despite having shape, the Normals may be wrong.
    *   Use **Attributes > Normals**.
    *   Click **Recompute** (e.g., Area Angle Weighting) to restore 3D shading.

#### Finalizing
*   **Convert:** If working with Dynamic Meshes, use **Transform > Convert** to save as a **Static Mesh**.
*   **Save:** `Ctrl + Shift + S` to save the project and all new assets.

---

### 5. Collision Generation and Setup

#### A. Standard Collision Methods (Static Mesh Editor)
These are accessed via the Static Mesh Editor (Details panel or Collision menu).

##### 1. Simplified Collision (Primitives)
*   **Description:** Adds basic geometric shapes (Sphere, Capsule, Box).
*   **Performance:** Extremely cheap/performant.
*   **Usage:** Best for simple props, pillars, or flat floor slabs.
*   **Method:**
    *   Open Static Mesh.
    *   Menu: `Collision > Add Box Simplified Collision`.
    *   Result: A green wireframe box appears.
    *   *Note:* It detects bounds automatically. You can add multiple primitives.

##### 2. Auto Convex Collision
*   **Description:** Generates a simplified "shrink-wrap" around the mesh.
*   **Performance:** Medium cost.
*   **Precision:** More accurate than boxes, follows the shape.
*   **Configuration:**
    *   Menu: `Collision > Auto Convex Collision`.
    *   **Hull Count/Max Hulls:** Increases accuracy (and cost).
    *   **Max Vertices:** Controls detail of the hulls.
    *   Click **Apply**.
*   **Limitation:** It is not perfectly precise; shooting through a gap might still hit the collision hull.

##### 3. Complex Collision as Simple (Mesh-Based)
*   **Description:** Uses the actual render polygons of the model as the collision surface.
*   **Performance:** Most expensive/intensive.
*   **Accuracy:** 100% accurate (Per-polygon).
*   **Usage:** Best for staircases, window cutouts, or irregular shapes where players must pass through holes.
*   **Configuration:**
    *   Details Panel > Collision > **Collision Complexity**.
    *   Set to: **Use Complex Collision as Simple**.

#### B. Manual Composition (The "Bonus" Method)
*   **Concept:** Instead of using one complex mesh collision, build the collision using child components in a Blueprint.
*   **Workflow:**
    1.  Create a Blueprint Actor (`BP_Chair`).
    2.  Add the Static Mesh (set its collision to NoCollision).
    3.  Add **Box Collision** components as children.
    4.  Scale and move the boxes to cover specific parts (e.g., one box for the seat, one for the backrest).
*   **Benefit:** Precise control over hitboxes without the performance cost of Complex collision.

#### C. Modeling Mode Collision Tool (Optimization)
*   **Tool:** Dedicated **Collision** tool within Modeling Mode (`Shift + 5`).
*   **Method - V-HACD:** Volumetric Hierarchical Approximate Convex Decomposition.
    *   Breaks the mesh into multiple small convex parts.
    *   **Visualization:** Enable "Show Collision" (`Alt + C`) to see green wireframes.

---

### 6. Optimization Strategy
**Goal:** Limit variable interactions in the physics engine for performance and multiplayer predictability.

#### The Problem with "Complex as Simple"
*   While it allows players to walk through doorways/holes, it adds massive calculation overhead.
*   Physics objects and Nanite geometry interactions become heavy.

#### The Optimized Solution (Custom Primitive Composition)
Instead of using Complex collision for a house with a doorway:
1.  Set collision to **Project Default (Simple)**.
2.  Delete the auto-generated box that blocks the door.
3.  Manually add **Box Simplified Collisions**.
4.  Scale and position them:
    *   One box for the left wall.
    *   One box for the right wall.
    *   One box for the header above the door.
    *   (Duplicate using `Alt + Drag` and rotate as needed).
5.  **Result:** You have a physical hole the player can walk through, but the engine only calculates physics against a few simple boxes rather than thousands of polygons.

#### Physics Settings Table
| Setting Name | Function | Note |
| :--- | :--- | :--- |
| **Can Character Step Up On** | Allows player to walk up stairs without jumping. | Essential for stairs. |
| **Collision Presets** | Usually set to `BlockAll` for structural modeling. | |
| **Project Default** | Uses global engine settings. | |

### 7. Workflow Best Practices
*   **Face Orientation:** Ensure normals face outward (Front-facing) to avoid Lumen rendering artifacts.
*   **Pivot Alignment:** Always fix the pivot to `(0,0,0)` or Bottom Corner after modeling for easier placement.
*   **Material IDs:** Use PolyGroups to assign different IDs (Roof vs Walls) before converting to Static Mesh.
*   **Gotcha - Selection State:**
    *   If a mesh is selected, Cube Grid **adds** to it.
    *   If nothing is selected (Press `Esc`), Cube Grid creates a **new** asset.
    *   *Warning:* Ensure you don't have the Sky Sphere selected, or it will try to build on the sky.

## 6. NIAGARA - Particle System

![alt text](image-2.png)

- https://www.youtube.com/watch?v=nOirmGz8YG4
- https://www.youtube.com/watch?v=hnUQiwJweeg
- https://www.youtube.com/watch?v=ZAKTxE4VZ1U

### 1. What is Niagara?
Niagara is the modern particle and VFX system built into Unreal Engine 5. It provides a modular, programmable way to create visual effects (fire, smoke, sparks, trails, magical effects) without writing code. Effects are created by combining building blocks: systems, emitters, and modules.

#### 1.1 Core Terminology
*   **Niagara System:** A container that holds one or more emitters together into a full effect. It is the top-level asset placed in a scene.
*   **Emitter:** The component responsible for creating particles. It controls when particles spawn, initialize, update, and render.
*   **Particle:** A single point of visual data. They carry attributes like position, color, size, velocity, and life.
*   **Modules:** Small, reusable pieces of logic defining behavior (e.g., set number of particles, define initial color, apply forces).
*   **Parameters:** Named values storing data (float, int, vector, enums, structs, Data Interfaces) used by modules.

#### 1.2 Module Stack and Execution Order
Niagara processes modules in a specific stack order:
1.  **Emitter Spawn:** Runs once when the emitter is created (initial setup).
2.  **Emitter Update:** Runs every frame at the emitter level.
3.  **Particle Spawn:** Runs once for each particle when it is created (initial conditions).
4.  **Particle Update:** Runs continuously on each particle every frame (physics, color change, lifetime updates).
5.  **Render Modules:** Defines how particles are drawn (sprites, meshes, ribbons, lights).

#### 1.3 Niagara Editor Interface
*   **System Overview:** Shows all emitters inside the system.
*   **Emitter Stack:** Displays modules arranged into groups defining behavior.
*   **Timeline / Preview Viewport:** Simulates and previews the effect.
*   **Details Panel:** Shows settings for selected emitters or modules.

---

### 2. Project: Creating a Fire Particle (From Scratch)
*Source: 6.pdf*

#### Step 1: Create System
1.  Right-click in Content Browser -> **FX** -> **Niagara System**.
2.  Select **Create Empty System**.
3.  Name it `NS Fire`.

#### Step 2: Add Emitter
1.  Open the Editor. Click **Add Emitter**.
2.  Choose **Create Empty Emitter**.
3.  Name it `NE FireEmitter`.

#### Step 3: Configure Spawn
*   **Location:** Emitter Spawn section.
*   **Module:** Add **Spawn Rate**.
*   **Value:** Set Rate to **50 - 100** (generates 50-100 particles per second).

#### Step 4: Particle Lifetime
*   **Location:** Particle Spawn section.
*   **Module:** Add **Initialize Particle**.
*   **Value:** Set **Lifetime** to **1.0 – 2.0** seconds.

#### Step 5: Initial Size
*   **Location:** Initialize Particle module.
*   **Value:** Set **Sprite Size** to `(20, 40)` (Y value larger for vertical stretching).

#### Step 6: Upward Motion (Velocity)
*   **Location:** Particle Spawn section.
*   **Module:** Add **Add Velocity**.
*   **Value:** Set **Z Velocity** to `100–200` (makes fire rise).

#### Step 7: Add Randomness
*   **Method:** Add a **Random Vector** to velocity.
*   **Value:** Add small X and Y variation (e.g., `-20` to `20`) for natural flicker.

#### Step 8: Color Over Life
*   **Location:** Particle Update section.
*   **Module:** Add **Color Over Life**.
*   **Gradient Settings:**
    *   **Start:** Bright Yellow / White.
    *   **Middle:** Orange.
    *   **End:** Dark Red / Transparent.

#### Step 9: Size Over Life
*   **Location:** Particle Update section.
*   **Module:** Add **Scale Sprite Size**.
*   **Behavior:** Start small -> Grow slightly -> Fade out.

#### Step 10: Drag (Optional)
*   **Location:** Particle Update.
*   **Module:** Add **Drag**.
*   **Value:** `1–3` (slows particles naturally preventing excessive speed).

#### Step 11: Renderer
*   **Location:** Render section.
*   **Action:** Add **Sprite Renderer** (displays particles as 2D images facing the camera).

---

### 3. Niagara Fundamentals & Experiments
*Source: Introduction To Niagara Video*

#### Spawn Rate vs. Lifetime Logic
*   **Spawn Rate:** Defines how many particles spawn per second.
*   **Lifetime Issue:** If `Lifetime` is set to 1.0s, but particles persist, you may need to add the **Particle State** module to the **Particle Update** section. This module kills particles when their lifetime has elapsed.

#### Velocity Modules
*   **Add Velocity:** Can be added to **Particle Spawn** (initial velocity) or **Particle Update** (adds velocity every frame).
*   **Fix Issue:** If an error appears (red dot), clicking "Fix Issue" automatically adds missing dependencies.
*   **Random Range Vector:** Allows setting a Minimum and Maximum velocity (e.g., Min `-100`, Max `100`) to randomize particle speed and direction.
*   **Cone Velocity:** Spawns particles as if coming from a cone. You can adjust the `Cone Angle` (e.g., 10) and axis (X, Y, or Z).

#### Particle Initialization Options
*   **Color:** Can use **Random Range** to pick between two colors (e.g., Pink and Green) or **Random Hue/Saturation**.
*   **Size (Sprite Attributes):**
    *   **Uniform:** Fixed size (e.g., 100).
    *   **Random Uniform:** Random size between two values (e.g., 5 and 100).
    *   **Non-Uniform:** Set X and Y separately (e.g., 10, 20).
    *   **Random Non-Uniform:** Randomizes X and Y separately.
*   **Rotation:**
    *   **Random:** Spawns with random rotation.
    *   **Direct Angle:** Specify an exact angle.

---

### 4. Project: Magical Shockwave
*Source: Magical Shockwave Video*

#### Emitter 1: Energy Burst
*   **Template:** Directional Burst.
*   **Spawn:** **Spawn Burst Instantaneous**, Count: `500`.
*   **Location:** **Shape Location** module (changed from Sphere to **Ring**), Radius: `5`.
*   **Forces:**
    *   **Point Attraction Force:** Set strength to negative (`-50`) to repel particles outwards.
    *   **Fix Issue:** Adds "Apply Initial Forces" module automatically.
*   **Material:** Uses `Smoke SubUV` from Starter Content. Modified to be emissive by connecting Particle Color to Initial Color.
*   **SubUV Animation:**
    *   Texture is an 8x8 grid.
    *   Add **SubUV Animation** module in Particle Update.
    *   Range: `0` to `63`.
*   **Rotation:**
    *   **Initialize:** Sprite Rotation Mode set to **Random**.
    *   **Update:** **Sprite Rotation Rate** set to Random Range Float (`15` to `45`).
*   **Movement:**
    *   Gravity: `15` (slow rise).
    *   Drag: `1.1` to `1.5` (resistance).
    *   **Curl Noise Force:** Strength `25` (adds noise/turbulence).
*   **Scaling:**
    *   **Scale Sprite Size:** Use a curve (start `0.5`, adjust handles).
    *   **Scale Color:** Adjust Alpha curve for transparency.

#### Emitter 2: Energy Burst Fighter (Sparks)
*   **Duplicate** previous emitter.
*   **Adjustments:**
    *   Lifetime: `0.5` to `1.0`.
    *   Ring Radius: `10`.
    *   Attraction: `-100` (stronger push).
    *   Size: Reduce particle size.

#### Emitter 3: Burst Lines
*   **Duplicate** previous emitter.
*   **Renderer:** **Sprite Renderer** Alignment set to **Velocity Align**.
*   **Size:** **Random Non-Uniform**. Min/Max X = `1`. Scale Y to stretch.
*   **Scale Sprite Size:** Non-Uniform curve.
    *   X Start: `1` (constant).
    *   Y Start: `0.1` (stretches with time).
*   **Physics:** Delete Rotation/Curl Noise. Reduce Gravity to `5`. Reduce Drag to `0.8`.
*   **Sort Order:** Set to `1` to render in front.

#### Emitter 4: Floor Bounce
*   **Duplicate** previous emitter.
*   **Particles:** Reduce count to `200`. Lifetime `1` to `2` seconds.
*   **Forces:**
    *   **Add Velocity:** `80` (initial upward force).
    *   **Gravity:** `-200` (pulls them down).
*   **Collision:** Add **Collision** module. Bounciness `0.4`, Friction `0.05`.
*   **Color Logic:**
    *   **Scale Color:** Change XYZ Vector to **Vector from Float**.
    *   **Float from Curve:** Create a curve to reduce strength over age.

#### Emitter 5: Light
*   **Renderer:** Add **Light Renderer** (requires CPU simulation).
*   **Settings:** Disable "Use Inverse Squared Falloff" to see clearly in viewport.

#### System Settings
*   **Loop Behavior:** Set to **Once** (for a single shockwave event).

---

### 5. Project: Smoke Portal (Niagara Fluids)
*Source: Niagara Fluids Smoke Portal Video*

#### Part A: Particle Source Setup
1.  **Emitter:** Empty Emitter. **Spawn Rate**: `1000`.
2.  **Lifetime:** `3`. **Size:** Uniform `3`.
3.  **Location:** **Shape Location** -> **Torus**.
    *   Large Radius: `125`, Handle Radius: `25`.
    *   Rotation Mode: **Axis Angle** (default 90 degrees stands it up).
4.  **Motion:**
    *   **Vortex Force:** Axis X=`1`, Z=`0`. Force `100` (spins particles around the donut).
    *   **Drag:** Add Drag module to contain particles.
5.  **Size over Life:** **Scale Sprite Size**. Start `0`, Middle `1` (full size), End `0` (invisible).
6.  **Fluid Attributes:** Add **Set Fluid Source Attributes**.
    *   Temperature: `0`.
    *   Density: `0.3`.

#### Part B: Fluid Simulation (Smoke)
1.  **Emitter:** Add **Grid 3D Gas Master Emitter**.
2.  **Source:** In Emitter Summary, uncheck Sphere Source. Enable **Particle Source**.
    *   Name: Select the particle emitter created in Part A.
3.  **Simulation Settings:**
    *   Properties: **GPU Sim** (Fixed bounds).
    *   Grid Size: X `800`, Y `1200`, Z `600`.
    *   Resolution: Max `500`.
    *   Pressure Solve Iterations: `12`.
4.  **Physics:**
    *   **Buoyancy:** `0.1` (Positive value makes smoke heavy/fall, negative makes it rise).
    *   **Dissipation:** `0.9` (Removes smoke quickly).
    *   **Wind:** Enable **Calculate Wind**. Magnitude `10` (pushes smoke back for depth).
5.  **Collision:** Uncheck "Open Boundary -Z" to make smoke collide with the floor.
6.  **Visuals:** Turn off Sprite Renderer for the source particles so only smoke is visible.

#### Part C: Improvements
*   **Motion Velocity:** In **Set Fluid Source Attributes**, increase `Velocity Scale` to `2` to transfer more spin from particles to smoke.
*   **Floating Particles:**
    *   Duplicate the source emitter.
    *   Disable Fluid Attributes. Enable Sprite Renderer.
    *   **Curl Noise Force:** Strength `75` (firefly movement).
    *   **Color:** Random Range Blue.

---

### 6. Class Blueprints

#### Definition
A **Blueprint Class** is a reusable template that defines the structure (components) and behavior (logic) of an object. It allows creating multiple instances of an object where each shares logic but can have different properties.

#### Parent Classes
*   **Actor:** Object that can be placed/spawned in the world.
*   **Pawn:** Actor that can be "possessed" and receive input.
*   **Character:** Type of Pawn with walking ability.
*   **Player Controller:** Responsible for controlling a Pawn.
*   **Actor Component:** Reusable component added to any actor.

#### Core Interface Components
1.  **The Viewport:** The 3D assembly window ("Construction Site"). Used to transform components and establish parent-child hierarchy (e.g., Door handle attached to Door).
2.  **The Event Graph:** The "Brain." A visual scripting canvas for logic.
    *   **Execution Pins:** White arrows dictating code sequence. Unconnected pins do not run.
    *   **Data Flow:** "Pulses" of light on wires show data flow during debugging.

---

### 7. Project: Interactive Door Blueprint
*Source: 7.pdf*

#### Step 1: Components and Viewport
1.  **Create Blueprint:** Right-click -> Blueprint Class -> **Actor**. Name: `BP_Door`.
2.  **Static Mesh:** Add door mesh. *Note: Pivot must be at the hinge, not center*.
3.  **Collision:** Add **Sphere Collision**. Scale it to define the "Interaction Radius".

#### Step 2: Variables
*   **Create Variable:** Name `IsOpen`. Type `Boolean`.

#### Step 3: Event Logic
*   **Custom Events:** Create two events:
    *   `OpenDoor`: Sets `IsOpen` = True -> Triggers Animation.
    *   `CloseDoor`: Sets `IsOpen` = False -> Reverses Animation.
*   **Branch Node:** Checks Boolean variable. If True, follows True path; else False path.

#### Step 4: Animation (Timeline Node)
1.  **Add Node:** Add **Timeline** node.
2.  **Configuration:**
    *   **Length:** `1.0` second.
    *   **Track:** Add **Float Track** named `Z-Rotation`.
3.  **Keys:**
    *   Key 1: Time `0`, Value `0`.
    *   Key 2: Time `1.0`, Value `90.0` (Degrees).

#### Step 5: Applying Rotation
1.  Drag **Static Mesh** into graph.
2.  Add **SetRelativeRotation** node.
3.  **Split Struct Pin:** Right-click `New Rotation` pin -> **Split**. (Exposes X, Y, Z).
4.  **Connect:**
    *   Timeline `Z-Rotation` output -> `New Rotation Z` input.
    *   Timeline `Update` pin -> `SetRelativeRotation` execution pin.

#### Step 6: Execution Flow
*   **Open Logic:** Play Timeline if `IsOpen` is False -> Set `IsOpen` True.
*   **Close Logic:** Reverse Timeline if `IsOpen` is True -> Set `IsOpen` False.
*   **Optimization:** Connect `CloseDoor` event to **Reverse** input (not Reverse from End) to prevent snapping.

## 7. Unreal Engine 5 Blueprint & Interaction System Notes

![alt text](image-3.png)

- https://www.youtube.com/watch?v=RiGTU96KiIk
- https://www.youtube.com/watch?v=ZkOuSzhLsLw
- https://www.youtube.com/watch?v=Xw9QEMFInYU

### 1. Introduction to Blueprints

**Blueprint** is the visual scripting system of Unreal Engine. It uses nodes connected by wires to create logic.

*   **Uses:**
    *   Creating complete games, tools, and interactive products.
    *   Creating logic for characters, cars, weapons, UI, and AI.
    *   Useful for non-game applications like short films or architectural visualization.

#### The Blueprint Editor UI
When opening a Blueprint Class, the editor contains the following key windows:

*   **Viewport:** Displays the visual representation of the actor. Controls are similar to the main level viewport (WASD to move, Right-click to look, W/E/R for transform tools).
*   **Construction Script:** Logic that executes **before** the game starts (e.g., when moving objects in the editor).
*   **Event Graph:** Logic that executes **during** gameplay (runtime).
*   **Components Panel:** Lists the sub-objects (Meshes, Cameras, Colliders) that make up the Blueprint.
*   **Details Panel:** Shows properties of the selected component or variable (Location, Rotation, Materials, Default Values).
*   **My Blueprint Tab:** Lists Graphs, Functions, Macros, and Variables.
*   **Compiler Results:** Displays errors or warnings after compiling.

**Essential Toolbar Buttons:**
*   **Compile:** Checks for errors and converts nodes to machine-readable code. Must be done after every change.
*   **Save:** Saves the asset.
*   **Find:** Searches for nodes within the graph.

---

### 2. Blueprint Variables

Variables store data within a Blueprint. They are color-coded by type.

#### Creating and Configuring Variables
1.  Click the **+** icon in the "Variables" tab.
2.  Set the **Name** and **Variable Type** in the Details panel.
3.  **Default Value:** Set this in the Details panel (requires compiling first).
4.  **Instance Editable / Expose on Spawn:** Check these boxes to allow setting the variable's value from the Level Editor (per instance).

#### Common Variable Types
*   **Boolean (Red):** True or False statement.
*   **Integer (Cyan/Green):** Whole numbers (e.g., 1, 55, 100). No decimals.
*   **Float (Green):** Decimal numbers (e.g., 1.5, 99.9). Used for percentages or health.
*   **String (Magenta):** Alpha-numeric text (letters, numbers, characters).
*   **Vector (Yellow/Gold):** Contains three Float values (X, Y, Z). Used for **Location** or RGB color.
*   **Rotator (Purple):** Contains three Float values (Roll, Pitch, Yaw). Used for **Rotation**.
*   **Transform (Orange):** Combines Location (Vector), Rotation (Rotator), and Scale (Vector).

#### Using Variables
*   **Get:** Retrieves the current value of the variable.
*   **Set:** Updates/Changes the value of the variable.
*   **Conversion:** Dragging a pin of one type (e.g., Integer) to another (e.g., String) often automatically creates a conversion node.

---

### 3. Level Blueprints

A **Level Blueprint** is a specialized Blueprint that controls logic specific to a single map (.umap).

#### Key Characteristics
*   **Scope:** Exists only once per level.
*   **References:** Can directly reference actors placed in the Viewport (Level).
*   **Usage:** Best for cinematic triggers, room-specific logic, and environment events.
*   **Limitations:** Cannot be reused in other levels.

#### Comparison: Level Blueprint vs. Blueprint Class

| Feature | Level Blueprint | Blueprint Class |
| :--- | :--- | :--- |
| **Scope** | One Level Only | Reusable Anywhere |
| **Referencing** | Direct References (Select & Right-click) | No Direct Level References |
| **Best For** | Scene Logic, Cinematics | Reusable Objects (Doors, Pickups) |
| **Files** | Embedded in Map | Saved in Content Browser |

#### Example 1: Timed Light Color Change (Level BP)
**Goal:** Change a Point Light color 5 seconds after the game starts.
1.  Select the **Point Light** in the Viewport.
2.  Open **Level Blueprint**.
3.  Right-click graph -> **Create Reference to PointLight**.
4.  Add `Event BeginPlay` node.
5.  Add `Delay` node (Duration = 5.0).
6.  Add `Set Light Color` node (Target = Point Light Reference).
7.  Select color (e.g., Red).
8.  **Flow:** `BeginPlay` -> `Delay` -> `Set Light Color`.

#### Example 2: Interactive Trigger Box (Level BP)
**Goal:** Toggle Light and Sound when entering/exiting a specific area.
1.  **Setup:** Place Point Light, Trigger Box, and Sound Cue in level.
2.  **Events:** Select Trigger Box -> Open Level BP -> Right-click -> Add `OnActorBeginOverlap` and `OnActorEndOverlap`.
3.  **Logic:**
    *   **Enter:** `OnActorBeginOverlap` -> `Set Visibility` (Light Ref, New Visibility = True) -> `Play Sound at Location`.
    *   **Exit:** `OnActorEndOverlap` -> `Set Visibility` (Light Ref, New Visibility = False) -> `Play Sound at Location`.
4.  **Note:** Use `Cast To Character` to ensure only the player triggers the event.

---

### 4. Blueprint Classes: Project Examples

#### 4.1. Interactive Door (Timeline Animation)
**Goal:** A reusable door actor that opens/closes when the player presses 'E'.

**Setup:**
1.  Create Actor Blueprint (`BP_Door`).
2.  Add **Static Mesh** (Door Frame) and **Static Mesh** (Door).
3.  Add **Box Collision** (to detect player presence).
4.  **Collision Fix:** If the player walks through the door mesh, open the static mesh editor and add "Box Simplified Collision".

**Logic (Event Graph):**
1.  **Enable Input:**
    *   `OnComponentBeginOverlap` (Box) -> `Cast to ThirdPersonCharacter` -> `Enable Input` (Player Controller = `Get Player Controller`).
    *   `OnComponentEndOverlap` (Box) -> `Cast to ThirdPersonCharacter` -> `Disable Input`.
2.  **Toggle Movement:**
    *   Input Key (E) -> `Flip Flop` (A = Open, B = Close).
3.  **Smooth Animation (Timeline):**
    *   Add `Timeline` node. Inside, add **Float Track**. Add keys: (0s, 0) and (2s, 90). Right-click keys -> **Auto** for smooth curve.
    *   **Update Pin:** `Set Relative Rotation` (Target = Door Mesh).
    *   **Conversion:** Connect Timeline Float output to Z axis of `Make Rotator`, then to Rotation input.
    *   **Direction:** Connect Flip Flop 'A' to `Play`, 'B' to `Reverse`.

#### 4.2. Interaction System (Interfaces vs. Casting)
**Goal:** A scalable system where the player can interact with different objects (Doors, Pickups) without hard dependencies.

**The Problem with Casting:**
*   Casting creates hard references. Loading the player blueprint loads every object it casts to into memory.
*   Requires unique logic for every class (e.g., Cast to Door, if fail -> Cast to Pickup).

**The Solution: Blueprint Interfaces (BPI)**
*   Defines *what* function exists (e.g., "Interact") but not *how* it works.

**Implementation Steps:**
1.  **Create Interface:** `BPI_Interactable`. Add function `Interact` (Input: Interactor Actor).
2.  **Implement in Actors:**
    *   In `BP_Pickup` and `BP_Door`, go to Class Settings -> Implemented Interfaces -> Add `BPI_Interactable`.
    *   Double-click `Interact` in the "Interfaces" list to implement the logic.
3.  **Actor Logic:**
    *   **Pickup:** Print String -> Play Sound -> `Destroy Actor`.
    *   **Door:** Toggle Open/Close logic.
4.  **Player Logic:**
    *   Create Variable `InteractablesInRange` (Actor Array).
    *   **Detection:**
        *   `OnComponentBeginOverlap` -> `Does Implement Interface`? -> If True, `Add Unique` to Array.
        *   `OnComponentEndOverlap` -> `Remove` from Array.
    *   **Interaction:**
        *   Input (E) -> Get Array Element (0) -> Call `Interact (Message)`.
        *   **Note:** The "Message" call does nothing if the target doesn't implement the interface (no errors, no casting needed).

#### 4.3. Hat Pickup (Sockets & Attachment)
**Goal:** Pick up an item and attach it to the character's body.

**Setup:**
1.  **Socket:** Open Character Skeleton -> Find Head Bone -> Add Socket (`HatSocket`). Add Preview Asset to position correctly.
2.  **Character BP:**
    *   Add Static Mesh Component (`HatMesh`).
    *   Create Custom Event `EquipHat` (Input: Static Mesh Reference).
    *   Logic: `Set Static Mesh` -> `Attach Component To Component` (Parent = Mesh, Socket Name = `HatSocket`, Location/Rotation Rule = Snap to Target).
3.  **Pickup BP:**
    *   `OnComponentBeginOverlap` (Sphere) -> `Enable Input`.
    *   Input (E) -> `Cast to Character` -> Call `EquipHat` (Pass self mesh) -> `Destroy Actor` (Self).

#### 4.4. Health and Damage System
**Goal:** Create zones that damage or heal the player over time, visualized by a UI bar.

**Character Setup:**
1.  Add Float Variable `Health` (Default 100).
2.  Add `AnyDamage` Event: `Health` = `Health` - `Damage`.
3.  **UI (Widget):**
    *   Create Widget Blueprint. Add **Progress Bar**.
    *   Bind Percent: `Get Owning Player Pawn` -> Cast to Character -> Get Health -> Multiply by 0.01 (to convert 0-100 to 0.0-1.0).
    *   Add to Viewport: In Character BP `BeginPlay`, use `Create Widget` -> `Add to Viewport`.

**Damage Box Logic:**
1.  `OnComponentBeginOverlap` -> Cast to Character -> **Promote to Variable** (Character Ref).
2.  `Set Timer By Event` (Looping, 1s).
3.  **Timer Event:** `Apply Damage` (Target = Character Ref, Base Damage = 10).
4.  **Stop Damage:** `OnComponentEndOverlap` -> `Clear and Invalidate Timer by Handle`.

**Health Box Logic:**
1.  Similar Timer setup.
2.  **Check:** Is `Health == 100`?.
    *   If True: Print "Full Health".
    *   If False: `Set Health` = `Health` + 10.

#### 4.5. Soccer Game (Physics & Respawning)
**Goal:** A physics-based ball that detects goals and respawns.

**Object Setup:**
*   **Ball:** Static Mesh. Enable **Simulate Physics**. Mass = 20. Collision = Sphere Simplified (removed original complex collision).
*   **Goal:** Collision = "Use Complex Collision As Simple" (to allow ball inside the net). Add Box Collision for the score zone.

**Logic:**
1.  **Scoring:** Goal Box `OnComponentBeginOverlap` -> Cast to Ball -> `Spawn Emitter at Location` (Confetti) -> `Destroy Actor` (Ball).
2.  **Respawning:**
    *   Store Spawn Location: On `BeginPlay`, check `IsValid` (Ball Ref). If valid, Get Actor Location -> Set `SpawnTransform` Variable.
    *   After Destroy: `Delay` (2s) -> `SpawnActorFromClass` (Class = Ball, Transform = `SpawnTransform`).
    *   **Exposed Reference:** Make Ball Reference variable "Instance Editable". In Level, pick the specific ball to link the goal to its specific ball.

#### 4.6. Hit Actor (Physics Impulse & Ragdoll)
**Goal:** An obstacle that spins and launches the player on contact.

**Setup:**
*   **Components:** Rotating Movement Component (Auto-spins). Arrow Component (defines launch direction). Capsule Collision.
*   **Variable:** `RotationRate` (Rotator, Exposed) to customize spin speed per instance.

**Launch Logic (Sequence):**
1.  **Hit Detection:** Capsule `OnComponentBeginOverlap` -> Cast to Character -> Call Custom Event `HitByHitActor`.
2.  **Character Ragdoll & Launch:**
    *   `Set Simulate Physics` (Mesh) = True.
    *   `Disable Movement` (Character Movement Component).
    *   **Impulse:** `Add Impulse` (Mesh). Vector = `HitActor Arrow Forward Vector` * 50,000.
    *   **Prevention:** Use Boolean `IsKnockedOut` to ensure logic runs only once per hit.
3.  **Reset (After Delay):**
    *   `Set Simulate Physics` (Mesh) = False.
    *   **Reattach:** `Attach Component To Component` (Mesh to Capsule). Snap to Target.
    *   **Correct Alignment:** `Set Relative Location` (e.g., Z = -89) and `Set Relative Rotation` (e.g., Z = 270) to match default mesh transform.
    *   `Set Movement Mode` = Walking.
    *   Reset `IsKnockedOut` = False.

**Edge Case:**
*   **Camera Collision:** If the camera clips into the object, change Collision Preset to "Custom" and set **Camera** channel to **Ignore**.
*   **Hat Glitch:** If an attached hat causes physics issues, set Hat Mesh collision to "No Collision".

## GDD 1st Half

![alt text](image-4.png)

### Game Design and Development Notes

#### 1. Games and Play Theory

##### Definition of a Game
A game can be defined as a **rule-based formal system** with a **variable and quantifiable outcome**.
*   Outcomes are assigned different values.
*   The player exerts effort in order to influence the outcome.
*   The player feels attached to the outcome.
*   The consequences of the activity are optional and negotiable.

##### Elements of a "Killer Game"
Is there a formula to design a killer game? The creative process involves the following elements:
*   **Aesthetic (Ae)**
*   **Fun (Fu)**
*   **Character (Cr)**
*   **Levels (Lv)**
*   **Addiction (Ad)**
*   **Story (St)**
*   **Mechanic (Me)**
*   **Genre (Ge)**
*   **Audio (Au)**
*   **Originality (Or)**
*   **Feel (Fe)**
*   **Pacing (Pa)**
*   **Art (Ar)**
*   **Coding (Co)**
*   **Interface (In)**
*   **Strategy (St)**
*   **Reward (Rw)**
*   **Planning (Pl)**
*   **Feedback (Fe)**
*   **Testing (Te)**

##### Rules and Game Mechanics
*   **Core Concept:** What all games share with one another is **rules**.
*   **Video Games:** In video games, rules can also be thought of as the game’s **“mechanic”**.
*   **Example:** The mechanic of a first-person shooter (FPS) game is shooting things. The action of the game is defined by the mechanic of:
    *   Damage
    *   Aiming
    *   Running
    *   Jumping
    *   Hiding
*   **World Rules:** The game mechanic is also informed by the rules of the world, such as:
    *   What you can and cannot shoot.
    *   How much damage you can inflict or sustain.
*   **Discipline of Game Design:** Minor additions to game rules speak to the discipline of game design, such as:
    *   Time limits
    *   Proximity
    *   Agreements of fairness

##### Game Evolution and Variants
From variations on a core mechanic, more games evolve. This is a common phenomenon in game design.
*   **Case Study:** Tag vs. Stick in the Mud
    *   From a “core” game such as **Tag**, variants emerge such as **“Stick in the Mud.”**
    *   It is the same game but with the twist that tagged players are stuck.
    *   Another “free” player must tag them to liberate them from the imagined “mud.”
    *   The goal of the “it” player here is to entrap all of the active players in order to “win.”

##### Definition of Play
*   A free activity standing quite consciously outside “ordinary” life.
*   An activity connected with **no material interest**, and **no profit** can be gained by it.
*   Proceeds within its own proper boundaries of time and space according to **fixed rules** and in an orderly manner.
*   Play, unlike real life, can take place anywhere and for any amount of time.
*   Play is **controlled** and excludes those not playing the game.
*   Play is essentially a **reward unto itself**.

##### Classroom Activities (Using Miro)
*   **Activity 1:** Divide into teams. Each team brings out 2 core games and tells the variants available as video games.
*   **Activity 2:** Answer: Do you take Social Media as a game? If yes, list down the rules/mechanics of this game.
*   **Activity 3:** Take a game and dissect its game rules and mechanics.
    *   What do the rules tell you about the game?
    *   How do the mechanics support and enhance both the rules and the gameplay?

---

#### 2. The Game World

##### Questions Before Game Design
*   In what way is my world more interesting than the real world?
*   Does my world focus on one individual’s story or can several stories be told?
*   How will the player internalize my world?

##### Constructing a Universe
When you build a game you construct a Universe. It will have:
*   **Physics**
*   **Boundaries**
*   **Interfaces**

##### The Building Blocks of Game World Design
1.  **The Field of Play**
2.  **The Game Mechanic**
3.  **The Rules of Play**
4.  **The Outcomes of Play**
5.  **The Objectives of Play**
6.  **Player Resources and Conflict**

###### 1. The Field of Play
*   **Consistency:** Must be consistent and work within the mechanics and rules of the game world.
*   **Interface:** The design of the interface between the player and the world is an aspect of the field of play (How does the player navigate through the world and how does the world react to the player?).
*   **Boundaries/Tasks:** Can be thought of as the game’s boundaries, tasks, and outcomes.
*   **Media:** Defined by the media it is played on.
*   **Stability:** Game worlds can be generated to be infinite or ever-changing, but the rules and mechanic must remain consistent.
*   **Level Design:** The field of play can constrain and guide the player towards a goal.

###### 2. The Game Mechanic
*   Does not just refer to the “nuts and bolts” or programming/art assets.
*   The mechanic is what the game is, how it plays, and how the player interacts with the game.
*   Mechanics explain the gameplay, environment, and physics of the world.
*   They are what a player can and cannot do, as well as how they interact within the game space.

###### 3. The Rules of Play
*   Rules limit actions.
*   Rules must be explicit, unambiguous, and consistent.
*   The game should never give the impression of “cheating” the player by changing rules and outcomes on the fly.
*   Rules have to be consistent *within* the game, but they do not have to be consistent *across* games.
*   In video games, the rules define the potentiality of any space for play and define and restrict an array of possible actions.

##### General Design Document Requirements
A general document should include:
*   **Overview:** The game’s premise (what the game is and what platform it is intended for).
*   **Story:** If there is one.
*   **Concepts for Level Designs:** Environments (mood boards or sketched art).
*   **Gameplay:** What is the mechanic? What are the rules?
*   **Art:** Sketches, mood boards, tone art (What does the world look like?).
*   **Sound and Music:** How much will there be? Do specific characters have specific sounds? Does each level require new music?
*   **User Interface:** Game controls (which may change, but it is useful to know if controls are "conventional" or unique/unusual).

---

#### 3. Ludology

**Definition:** Ludology is the name for the study of games and game design.

##### Common Frameworks
1.  **MDA:** Mechanics, Dynamics, and Aesthetics.
2.  **FDD:** Formal, Dramatic, and Dynamic elements.
3.  **Elemental Tetrad:** Splits games into four core elements (Mechanics, Aesthetics, Story, Technology).

##### MDA Framework
*   **Mechanics:** The particular components of the game at the level of data representation and algorithms.
*   **Dynamics:** The runtime behavior of the mechanics acting on player inputs and each other’s outputs over time.
*   **Aesthetics:** The desirable **emotional responses** evoked in the player when they interact with the game system.
*   **Views:**
    *   **Designers:** Mechanics $\rightarrow$ Dynamics $\rightarrow$ Aesthetics.
    *   **Players:** Aesthetics $\rightarrow$ Dynamics $\rightarrow$ Mechanics.

##### FDD: Formal, Dramatic, and Dynamic Elements

###### 1. Formal Elements
Elements that make games different from other forms of media or interaction and provide the structure.
*   **Player Interaction Pattern:** How players interact.
    *   Single-player
    *   One-on-one
    *   Team versus team
    *   Multilateral (multiple players vs. each other, e.g., board games)
    *   Unilateral (one player vs. all others, e.g., *Scotland Yard* or *Mario Party* minigames)
    *   Cooperative play
    *   Multiple individual players vs. the same system
*   **Objective:** What players are trying to achieve. When someone has won.
*   **Rules:** Limit actions. Can be **Explicit** (written) or **Implicit** (understood, e.g., don't steal from the bank in *Monopoly*).
*   **Procedures:** The types of actions taken by players. A rule tells you *to* roll; the procedure is the *action* of rolling.
*   **Resources:** Elements with value (money, health, items, property).
*   **Boundaries:** Where the game ends and reality begins.
*   **Outcome:** How the game ended (final and incremental outcomes).

###### 2. Dramatic Elements
Help make rules/resources understandable and provide emotional investment.
*   **Premise:** The basic story of the game world (e.g., *Monopoly*: real-estate developers in Atlantic City). Forms the basis of the narrative.
*   **Character:** Individuals around whom the story revolves.
*   **Story:** The plot. The actual narrative that takes place. The premise sets the stage for the story.

###### 3. Dynamic Elements
Elements that occur only when the game is being played.
*   **Emergence:** Collisions of seemingly simple rules lead to unpredictable outcomes.
*   **Emergent Narrative:** A breadth of narratives emerging from the gameplay itself. Games put players in extra-normal situations, leading to interesting stories.

##### The Elemental Tetrad (Schell)
Focuses on static elements "as it comes in a box."
*   **Mechanics:** Rules for interaction. Differentiates games from non-interactive media. (Note: different from MDA mechanics; includes rules/objectives).
*   **Aesthetics:** How the game is perceived by the **five senses** (vision, sound, smell, taste, touch). Includes soundtrack, packaging, art. (Note: different from MDA aesthetics which refers to emotional response).
*   **Technology:** Underlying technology that makes the game work.
    *   Digital: Console hardware, software, rendering pipelines.
    *   Analog: Dice, cards, stats, tables.
*   **Story:** Narrative elements, premise, and characters.
*   **Visibility:** Aesthetics are most visible. Technology is least visible (players understand mechanics better than probability distributions).

---

#### 4. Unreal Engine 5.6.1 (Class 1)

**Date:** 2 February 2026

##### 1. Editor Basics

###### 1.1 Editor Layout
*   **Viewport:** Main 3D area where levels are built.
*   **Outliner:** Lists all actors in the scene.
*   **Details Panel:** Shows editable properties of selected actor.
*   **Content Drawer:** Stores all project assets.
*   **Place Actors Panel:** Drag shapes, lights, and volumes into the scene.

###### 1.2 Essential Shortcuts
| Action | Shortcut |
| :--- | :--- |
| **Content Drawer** | `Ctrl + Spacebar` |
| **Move Camera** | `Right-click + W/A/S/D/E/Q` |
| **Fast Camera Movement** | Hold Middle Mouse Button + Scroll Up |
| **Slow Camera Movement** | Hold Middle Mouse Button + Scroll Down |
| **Focus Object** | `F` |
| **Save Level** | `Ctrl + S` |
| **Grouping Meshes** | `Ctrl + G` |
| **Ungrouping Meshes** | `Shift + G` |
| **Duplicate Object** | `Alt + Drag` |
| **Move Tool** | `W` |
| **Rotate Tool** | `E` |
| **Scale Tool** | `R` |
| **Directional Lighting** | `Ctrl + L` |

###### 1.3 The Content Drawer
The central asset management panel. Functions as the project file system.
*   **Key Functions:**
    *   Stores assets in organized folders.
    *   Imports files (textures, models, audio).
    *   Quick search and filtering.
    *   Drag-and-drop into viewport.
    *   Creates new assets (Blueprints, Materials, Levels).
*   **Access:** `Ctrl + Space` or click the drawer tab (bottom-center).

##### 2. Introduction to FAB
FAB is Epic Games’ unified asset marketplace (replacing Unreal Marketplace and Quixel Bridge).
*   **Key Features:**
    *   **Unified Marketplace:** Assets from Unreal Marketplace, Quixel Megascans, Sketchfab.
    *   **High-Quality Free Assets:** Filter by "Free" to find grass, rocks, landscapes.
    *   **One-Click Import:** Download and add directly to project.
    *   **Optimized for UE5:** Nanite, Lumen, modern workflow.
*   **Accessing:** Open Content Drawer $\rightarrow$ Click **Fab button** (bottom toolbar) $\rightarrow$ Browse $\rightarrow$ Add to Project.

##### 3. Creating a New Level
1.  **Start:** Content Drawer $\rightarrow$ Right Click $\rightarrow$ New Level $\rightarrow$ Empty Level.
2.  **Add Essential Actors:** Window $\rightarrow$ Env. Light Mixture. Add:
    *   Sky Atmosphere
    *   Directional Light (Sun)
    *   Sky Light
    *   Player Start
    *   Exponential Height Fog

##### 4. Basic Shapes (Primitives)
*   **Available:** Cube, Sphere, Cylinder, Cone, Plane.
*   **Adding:** Drag from Place Actors Panel OR Right-click in viewport $\rightarrow$ Add Shape.

##### 5. Building a Simple Room (Workflow)
1.  **Create Floor:** Landscape Mode $\rightarrow$ Add landscape.
2.  **Make Door Opening:**
    *   Drag **Door** static mesh from content drawer.
    *   Use **DoorFrame Corner** and **DoorFrame Edge** static meshes.
    *   Use `Shift` to select multiple assets and duplicate.
3.  **Create Walls:**
    *   Drag **Cube**.
    *   Move to side.
    *   Duplicate (`Alt + Drag`) to form 4 sides.
4.  **Add Spot Lights:**
    *   Place Actors $\rightarrow$ Search **Spot Light**.
    *   Drag into interior.
    *   Position near ceiling, aim downward (`E`).
    *   Duplicate for even lighting.
5.  **Test:** Press **Play**. Walk with WASD. Check lighting/height.

##### 6. Foliage
Allows fast placement of natural assets.
1.  Switch to **Foliage Mode** (Shift + 3).
2.  Click **+ Add** $\rightarrow$ Search FAB Grass.
3.  Enable checkbox next to asset.
4.  Adjust **Brush Size**, **Density**, **Paint Radius**.
5.  Click and drag to paint.
    *   *Tip:* Hold `Shift` while painting to erase.

##### 7. Precision Tools
*   **Transform Controls:** Details panel for exact Location, Rotation, Scale.
*   **Snapping Controls:**
    *   Translation Snap: 10 units (default).
    *   Rotation Snap: 10 degrees (default).

##### 8. Play Testing
*   Add **Player Start**.
*   Press **Play** (Gameplay Preview).
*   `ESC` to exit.

---

#### 5. Modeling Mode & Collision

**Access:** Selection Mode $\rightarrow$ Modeling (or `Shift + 5`).
**Core Concept:** "Model from Scratch" inside the engine. Non-destructive, rapid iteration. No need for Blender/Maya for simple shapes.

##### Project Setup
*   **Edit > Project Settings > Plugins > Modeling Mode**.
*   **Generated Assets:** Change location to **Global Asset Path**.
*   Set path name (e.g., `MyModels`).
*   Disable "Per User Folder" to avoid username subfolders.

##### Primary Toolset: Cube Grid
Operates on a 2D selection grid projected into 3D space.
*   **Grid Size:** Step Size = $2^n \times 10$ units.
    *   **100 cm:** Large blocking.
    *   **50 cm:** Thick walls/floors.
    *   **10 cm:** Detail work.
*   **Shortcuts:** `Ctrl + E` (Double grid), `Ctrl + Q` (Halve grid). `Z` (Grid Power).

###### Actions
*   **Grid Selection:** Click and drag.
*   **Extrusion (E):** Move face **outward** (add geometry).
*   **Depression/Subtraction (Q):** Push face **inward** (delete/void).
*   **Interactive Push/Pull:** `Ctrl + Left Mouse Drag`.
*   **Corner Mode (Z):** Select individual corners for slanted/diagonal surfaces.

##### Construction Techniques

###### 1. Basic Room
*   **Floor:** Grid size 100. Select area. Extrude (`E`) up one unit.
*   **Walls:** Select outer perimeter. Extrude up (e.g., 4 times).
*   **Windows/Doors (Boolean):**
    *   Select grid area on vertical wall.
    *   Press `Q` to punch hole (Manifold-safe).
    *   *Revision:* `Ctrl + Drag` edge of hole to fill back in.

###### 2. Roof Geometry (Pitched)
1.  Extrude top to roof height.
2.  Use **Corner Mode**.
3.  Select ridge line (center edge).
4.  Press `Q` or drag down to slope.

###### 3. Staircase Design
*   **Staggered Method (Cube Grid):** Draw steps manually. Rise: 20cm, Run: 30-40cm.
*   **Automated Method:**
    1.  Use **Stair** shape tool (Dynamic Mesh).
    2.  **Plane Cut** (TriModel) to cut in half (rotate 90 deg, "Keep Both Halves", "Fill Cut Hole").
    3.  Re-orient for turns.
    4.  Add Box for Landing.
    5.  **PolyEdit:** Snap landing face to stair vertex (`Ctrl + Drag`).
    6.  **Merge:** `Mesh Ops > Union`.
    7.  **Pivot:** Set to Bottom.

###### 4. Mirroring
*   Use **Mirror** tool (TriModel).
*   Settings: **Mirror and Append**, **Weld Vertices**, **Crop along mirror plane**.

##### Mesh Refinement
*   **PolyGroup Edit:**
    *   **Merge Faces:** Combine small faces.
    *   **Beveling:** Add chamfer to edges.
*   **Materials:**
    *   Use **Material Edit** (Attributes).
    *   Add new material slot.
    *   Brush Mode: **All in Group**. Select faces $\rightarrow$ Assign Active Material.
*   **UVs:** Use **Project** tool (Plane or Box projection). Adjust Scale.
*   **Normals:** Use **Attributes > Normals > Recompute** (Area Angle Weighting) to fix flat lighting.
*   **Finalize:** `Transform > Convert` to Static Mesh. `Ctrl + Shift + S` to save.

##### Collision Generation
**Goal:** Limit variable interactions for performance.

###### Standard Methods (Static Mesh Editor)
1.  **Simplified (Primitives):** Box, Sphere, Capsule. Cheapest/Fastest. Best for props/pillars.
2.  **Auto Convex (Hulls):** "Shrink-wrap." Medium cost. Adjustable Hulls/Vertices.
3.  **Complex as Simple (Mesh-Based):** Uses actual polygons. **Most Expensive.** 100% accurate.
    *   Setting: `Collision Complexity` $\rightarrow$ `Use Complex Collision as Simple`.

###### Optimization Strategy (Manual Composition)
Instead of "Complex as Simple" for a house with a door:
1.  Set collision to **Project Default (Simple)**.
2.  Delete auto-generated blocking box.
3.  Manually add **Box Simplified Collisions** inside the blueprint/mesh editor.
4.  Scale/Position boxes for walls and header.
5.  *Result:* Physical hole exists, but engine calculates simple boxes.

###### Modeling Mode Collision Tool
*   Method: **V-HACD** (Volumetric Hierarchical Approximate Convex Decomposition).
*   Visualization: `Alt + C`.

###### Physics Settings Table
| Setting Name | Function |
| :--- | :--- |
| **Can Character Step Up On** | Allows player to walk up stairs without jumping. |
| **Collision Presets** | Usually set to **BlockAll** for structural modeling. |
| **Project Default** | Uses global engine settings. |

##### Workflow Best Practices
*   **Face Orientation:** Check normals face outward (Front-facing) for Lumen.
*   **Pivot Alignment:** Fix pivot to (0,0,0) or Bottom Corner using **Edit Pivot**.
*   **Material IDs:** Use PolyGroups for different IDs before converting.
*   **Selection Warning:** If a mesh is selected, Cube Grid adds to it. If nothing selected, it creates a new asset. Do not select Sky Sphere.

---

#### 6. Niagara - Particle System

**Definition:** Modern, modular, programmable VFX system.
**Hierarchy:**
*   **Niagara System:** Top-level container. Holds emitters. Placed in level.
*   **Emitter:** Generates particles. Controls lifecycle.
*   **Particle:** Single visual point (position, color, velocity).
*   **Modules:** Reusable logic blocks (e.g., Spawn Rate).
*   **Parameters:** Data (float, int, vector).

**Execution Order (Stack):**
1.  **Emitter Spawn:** Runs once on creation.
2.  **Emitter Update:** Runs every frame (emitter level).
3.  **Particle Spawn:** Runs once per particle creation.
4.  **Particle Update:** Runs every frame per particle.
5.  **Render:** Draws particles.

##### Tutorial 1: Basic Fire (From Scratch)
1.  **Create System:** Right-click $\rightarrow$ FX $\rightarrow$ Niagara System $\rightarrow$ Empty System ("NS Fire").
2.  **Add Emitter:** Create Empty Emitter ("NE FireEmitter").
3.  **Spawn:** Emitter Spawn $\rightarrow$ **Spawn Rate** (50-100).
4.  **Lifetime:** Particle Spawn $\rightarrow$ **Initialize Particle** (Lifetime 1.0-2.0s).
5.  **Size:** Initialize Particle $\rightarrow$ **Sprite Size** (20, 40) (Stretch Y).
6.  **Velocity:** Particle Spawn $\rightarrow$ **Add Velocity** (Z: 100-200).
7.  **Randomness:** Add **Random Vector** to velocity (-20 to 20 X/Y).
8.  **Color:** Particle Update $\rightarrow$ **Color Over Life** (Yellow $\rightarrow$ Orange $\rightarrow$ Dark Red/Transparent).
9.  **Size Over Life:** Particle Update $\rightarrow$ **Scale Sprite Size** (Start small $\rightarrow$ Grow $\rightarrow$ Fade).
10. **Drag:** Particle Update $\rightarrow$ **Drag** (1-3).
11. **Render:** Add **Sprite Renderer**.

##### Tutorial 2: Magical Shockwave (Summary)
*   **Emitter 1 (Burst):** Spawn Burst Instantaneous (500). Shape Location: **Ring**. Point Attraction Force (Negative/Repel). Material: Emissive Smoke. SubUV Animation.
*   **Emitter 2 (Sparks):** Duplicate. Smaller, shorter life, stronger attraction.
*   **Emitter 3 (Burst Lines):** Renderer Alignment: **Velocity Align**. Scale Y to stretch. Sort Order 1.
*   **Emitter 4 (Floor Bounce):** Gravity (-200 pulls down). **Collision** module (Bounciness 0.4).
*   **Emitter 5 (Light):** Light Renderer.

##### Tutorial 3: Smoke Portal (Niagara Fluids)
*   **Part A (Source):** Emitter with **Torus** location. **Vortex Force** to spin. **Set Fluid Source Attributes** (Density 0.3).
*   **Part B (Fluid):** Add **Grid 3D Gas Master Emitter**. Set Source to "Particle Source" (select Part A).
    *   **Buoyancy:** 0.1 (Heavy smoke).
    *   **Wind:** Calculate Wind (Magnitude 10).
    *   **Collision:** Uncheck "Open Boundary -Z".

---

#### 7. Blueprints

**Definition:** Visual scripting system using nodes and wires.

##### Class Blueprint vs. Level Blueprint

| Feature | Level Blueprint | Blueprint Class |
| :--- | :--- | :--- |
| **Scope** | One Level Only | Reusable Anywhere |
| **Direct Referencing** | Yes (Select & Right-click) | No (Requires casting/references) |
| **Best For** | Scene Logic, Cinematics, Environmental Triggers | Reusable Objects (Doors, Pickups), Characters |
| **File Location** | Embedded in Map | Content Browser |

##### Blueprint Class Components
1.  **Viewport:** 3D assembly ("Construction Site"). Defines hierarchy.
2.  **Event Graph:** Logic ("Brain").
    *   **Execution Pins (White):** Order of operations.
    *   **Data Pins (Colored):** Value transfer.
3.  **Construction Script:** Logic executes before game starts (in editor).

##### Variables
*   **Boolean (Red):** True/False.
*   **Integer (Cyan):** Whole numbers.
*   **Float (Green):** Decimals.
*   **String (Magenta):** Text.
*   **Vector (Yellow):** XYZ Location/Color.
*   **Rotator (Purple):** Rotation.
*   **Instance Editable:** Allows changing value per instance in Level Editor.

##### Tutorial 1: Interactive Door (Class BP)
1.  **Create:** Actor Blueprint `BP_Door`. Add Static Mesh (Door) + Box Collision.
2.  **Variable:** `IsOpen` (Boolean).
3.  **Logic:**
    *   **Events:** `OpenDoor` (Set IsOpen True) / `CloseDoor` (Set IsOpen False).
    *   **Timeline Node:**
        *   Length: 1.0s.
        *   Float Track (`Z-Rotation`): 0 to 90.
    *   **Update:** `SetRelativeRotation` (Split Struct Pin). Connect Timeline Z to New Rotation Z.
    *   **Optimization:** Connect Close event to **Reverse** (not Reverse from End) to prevent snapping.

##### Tutorial 2: Light Color Change (Level BP)
1.  Select Point Light in Viewport.
2.  Open Level Blueprint.
3.  Right-click $\rightarrow$ **Create Reference to PointLight**.
4.  `Event BeginPlay` $\rightarrow$ `Delay` (5s) $\rightarrow$ `Set Light Color` (Red).

##### Tutorial 3: Trigger Box (Level BP)
1.  Place Trigger Box & Sound.
2.  Select Trigger $\rightarrow$ Level BP $\rightarrow$ Add `OnActorBeginOverlap` / `OnActorEndOverlap`.
3.  **Enter:** Cast to Character $\rightarrow$ Set Visibility (Light, True) $\rightarrow$ Play Sound.
4.  **Exit:** Cast to Character $\rightarrow$ Set Visibility (Light, False) $\rightarrow$ Play Sound.

##### Advanced Interaction Systems (From README)

###### 1. Blueprint Interfaces (BPI)
*   **Problem:** Casting creates hard references/memory load.
*   **Solution:** BPI defines *what* function exists ("Interact") but not *how*.
*   **Setup:**
    1.  Create `BPI_Interactable`. Function: `Interact`.
    2.  Implement in Actors (Door, Pickup).
    3.  **Player Logic:** Detect Overlap $\rightarrow$ Does Implement Interface? $\rightarrow$ Call `Interact` Message.

###### 2. Hat Pickup (Sockets)
1.  **Skeleton:** Add Socket to Head Bone (`HatSocket`).
2.  **Pickup Logic:** `Event` $\rightarrow$ Cast to Character $\rightarrow$ Call `EquipHat` $\rightarrow$ Destroy Self.
3.  **Character Logic:** Custom Event `EquipHat` $\rightarrow$ `Attach Component To Component` (Snap to Target, Socket Name: `HatSocket`).

###### 3. Health System (UI)
1.  **Variable:** `Health` (Float, 100).
2.  **Widget:** Progress Bar. Bind Percent: `Health * 0.01`.
3.  **Damage Box:** `OnBeginOverlap` $\rightarrow$ Set Timer (Loop) $\rightarrow$ `Apply Damage`.
4.  **Heal Box:** Check if Health < 100 $\rightarrow$ Add to Health.

###### 4. Soccer Game (Physics)
*   **Ball:** Enable **Simulate Physics**. Mass 20. Collision: Sphere Simplified.
*   **Goal:** Collision: "Complex as Simple". Add Box Collision for score zone.
*   **Logic:** Goal Overlap $\rightarrow$ Spawn Confetti $\rightarrow$ Destroy Ball $\rightarrow$ Delay $\rightarrow$ Respawn Ball (at saved Transform).

###### 5. Hit Actor (Impulse/Ragdoll)
*   **Setup:** Rotating Movement Component.
*   **Logic on Hit:**
    1.  Cast to Character.
    2.  Set Simulate Physics (Mesh) = True.
    3.  `Add Impulse` (Direction: Arrow Forward Vector * 50,000).
    4.  **Reset:** Delay $\rightarrow$ Simulate Physics False $\rightarrow$ `Attach Component To Component` (Reattach to Capsule) $\rightarrow$ Reset Rotation/Location.

## 9. Blueprint Visual Scripting

![alt text](image-8.png)

### What are Blueprints?
Blueprints are a **Visual Scripting System** designed to create gameplay elements and logic.

**Core Characteristics:**
*   **Node-based programming:** Logic is constructed by visually connecting nodes.
*   **No C++ code required:** Eliminates the need for traditional text-based programming.
*   **Visual logic flow:** Makes the execution path easy to read and understand.
*   **Rapid prototyping:** Speeds up the development and testing process.
*   **Designer-friendly:** Accessible to team members without a formal programming background.

#### Key Components
*   **Nodes**: Represent individual actions or commands.
*   **Pins**: Serve as the connection points between different nodes.
*   **Variables**: Used for data storage.
*   **Events**: Triggers that start a specific chain of logic.
*   **Functions**: Self-contained blocks of reusable logic.

---

### Level Blueprint vs. Class Blueprint

There are two primary types of Blueprints, each serving a distinct purpose in game development.

#### Level Blueprint
*   **Scope:** Restricted to one specific level only.
*   **Purpose:** Handles level-specific events and custom logic.
*   **Access Method:** `Blueprints → Open Level Blueprint`.
*   **Common Examples:**
    1.  Opening doors when the level starts.
    2.  Triggering cinematic cutscenes.
    3.  Managing level sequences.

#### Class Blueprint
*   **Scope:** Completely reusable across all levels in a project.
*   **Purpose:** Acts as templates and defines behaviors for specific objects.
*   **Access Method:** `Content Browser → Create Blueprint`.
*   **Common Examples:**
    1.  Player character controls.
    2.  Pickable or interactable items.
    3.  Enemy AI behavior.

---

### Level Blueprint Examples

#### 1. Automatic Door with Trigger Box
This script opens a door automatically when a player enters a specified area.

```text
1. Event: Actor Begin Overlap (TriggerBox)
   └─> Other Actor: Player Character

2. Action: Timeline - "Door Open"
   └─> Set Relative Location (Door)
       • Start: Z = 0
       • End: Z = 200
       • Duration: 1.5 seconds

3. Event: Actor End Overlap (TriggerBox)
   └─> Reverse Timeline
```

#### 2. Toggle Light with Key Press
This script turns a light on and off when the player presses a specific key.

```text
1. Event: F Key Pressed

2. Variable: IsLightOn (Boolean) = false

3. Logic Flow:
   └─> Branch (IsLightOn)
       ├─> True: Set Light Intensity = 0
       │         Set IsLightOn = false
       │
       └─> False: Set Light Intensity = 5000
                  Set IsLightOn = true

4. Target: Reference to PointLight1 in level
```

---

### Class Blueprint Examples

#### 1. Collectible Health Pack
This script handles the behavior of a health pack that the player can pick up to restore health.

**Required Components:**
*   **Static Mesh:** The visual model of the health pack.
*   **Sphere Collision:** The invisible trigger area for the pickup.

**Variables:**
*   `HealAmount` (Float) = 25.0
*   `RotationSpeed` (Float) = 90.0

```text
Event: Component Begin Overlap
└─> Cast to Character (Other Actor)
    ├─> Success:
    │   └─> Add Health (Character, HealAmount)
    │       └─> Destroy Actor (Self)
    │
    └─> Fail: Do Nothing
```

#### 2. Continuously Rotating Platform
This script makes a platform spin continuously at a steady rate.

**Required Components:**
*   **Static Mesh:** The platform's 3D mesh.

**Variables:**
*   `RotationSpeed` (Vector) = (0, 0, 45) *(Represents X, Y, Z rotation per second)*

```text
Event: Event Tick (Delta Seconds)
└─> Get Actor Rotation
    └─> Add (Rotation, RotationSpeed * Delta Seconds)
        └─> Set Actor Rotation
```
> **Note:** Multiplying by `Delta Seconds` ensures that the rotation remains smooth and independent of the game's frame rate.

#### 3. Pressable Button with Custom Event
This script creates an interactive button that triggers customizable events.

**Variables:**
*   `IsPressed` (Boolean) = false
*   `PressedLocation` (Vector) = (0, 0, -5)

```text
Event: Actor On Clicked
└─> Branch (NOT IsPressed)
    └─> True:
        ├─> Set IsPressed = true
        ├─> Add Relative Location (PressedLocation)
        └─> Call Custom Event: OnButtonPressed
```

**Custom Event: OnButtonPressed Details:**
*   Can be explicitly overridden in child blueprints to create variations.
*   Use an **Event Dispatcher** to communicate this action to a Level Blueprint.

---

### Blueprint Best Practices

To maintain clean, efficient, and bug-free logic, follow these best practices across three core areas:

#### Organization
*   Use **comments** to explain sections of logic.
*   Group related nodes together visually.
*   Name variables clearly and descriptively.
*   Create **functions** for any logic that needs to be reused.
*   Use folders within the *My Blueprint* panel to keep assets categorized.

#### Performance
*   Avoid placing heavy or complex logic inside the **Event Tick** node.
*   Use **timers** for tasks that need to repeat at intervals.
*   Cache references to objects instead of searching for them repeatedly.
*   Use **pure functions** whenever possible (functions that only output data without modifying state).
*   Minimize the use of **Cast** nodes, as they can be computationally expensive.

#### Debugging
*   Utilize **Print String** nodes to display values on screen.
*   Set **breakpoints** to pause execution and inspect the flow.
*   Watch specific variables to see how their values change in real-time.
*   Enable **Execute pins** to visually trace execution paths.
*   Test logic incrementally rather than all at once.

---

### Essential Blueprint Nodes

| Node Type | Purpose | Example Use |
| :--- | :--- | :--- |
| **Event Begin Play** | Runs exactly once when the actor spawns. | Initialize variables, spawn visual effects. |
| **Event Tick** | Runs continuously, firing every single frame. | Continuous movement, making an object look at the player. |
| **Branch** | Handles standard if/else logic flow. | Check specific conditions, switch between states. |
| **Cast To** | Checks the object type to ensure compatibility. | Get the player reference, verify a character's identity. |
| **Set Timer** | Handles delayed or repeated execution. | Respawn item pickups, manage ability cooldowns. |
| **Print String** | Outputs debug text directly to the screen. | Show current variable values, test logic triggers. |
| **Get/Set** | Reads (Get) or writes (Set) data to variables. | Access player health, modify position, update game states. |

---

### Variables & Data Types

Variables store different kinds of information necessary for game logic. They are divided into Basic and Advanced types.

#### Basic Types
*   **Boolean:** Stores `true` or `false` values.
    *   *Examples:* `IsAlive`, `CanJump`
*   **Integer:** Stores whole numbers without decimals.
    *   *Examples:* `Score`, `AmmoCount`
*   **Float:** Stores decimal numbers.
    *   *Examples:* `Health`, `Speed`
*   **String:** Stores plain text.
    *   *Examples:* `PlayerName`, `Message`

#### Advanced Types
*   **Vector:** Stores 3D coordinates (X, Y, Z).
    *   *Examples:* `Location`, `Velocity`
*   **Rotator:** Stores 3D rotation data (Pitch, Yaw, Roll).
    *   *Examples:* `ActorRotation`
*   **Object Reference:** Stores a direct link to a specific actor in the game world.
    *   *Examples:* `TargetEnemy`, `DoorRef`
*   **Array:** Stores a list or collection of multiple items.
    *   *Examples:* `Inventory`, `EnemyList`